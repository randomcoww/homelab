mode: Deployment

internalDomain: internal-dns.local

images:
  coreDNS: docker.io/coredns/coredns:latest
  externalDNS: k8s.gcr.io/external-dns/external-dns:v0.12.0
  etcd: ghcr.io/randomcoww/etcd:v3.5.4

serviceAccount:
  name: external-dns

priorityClassName: system-cluster-critical

replicaCount: 2
rollingUpdate:
  maxUnavailable: 1
  maxSurge: 25%

affinity: {}
tolerations: {}

service:
  type: NodePort
  clusterIP: ~
  port: 53
  nodePort: 30053

dataSources: []

hostNetwork:
  enabled: false

servers:
# - zones:
#   - zone: .
#   port: 53
#   # If serviceType is nodePort you can specify nodePort here
#   # nodePort: 30053
#   plugins:
#   - name: errors
#   # Serves a /health endpoint on :8080, required for livenessProbe
#   - name: health
#     configBlock: |-
#       lameduck 5s
#   # Serves a /ready endpoint on :8181, required for readinessProbe
#   - name: ready
#   # Required to query kubernetes API for data
#   - name: kubernetes
#     parameters: cluster.local in-addr.arpa ip6.arpa
#     configBlock: |-
#       pods insecure
#       fallthrough in-addr.arpa ip6.arpa
#       ttl 30
#   # Serves a /metrics endpoint on :9153, required for serviceMonitor
#   - name: prometheus
#     parameters: 0.0.0.0:9153
#   - name: forward
#     parameters: . /etc/resolv.conf
#   - name: cache
#     parameters: 30
#   - name: loop
#   - name: reload
#   - name: loadbalance

coreDNSLivenessProbe: {}
  # httpGet:
  #   path: /health
  #   port: 8080
  #   scheme: HTTP
  # initialDelaySeconds: 60
  # periodSeconds: 10
  # timeoutSeconds: 5
  # failureThreshold: 5
  # successThreshold: 1

coreDNSReadinessProbe: {}
  # httpGet:
  #   path: /ready
  #   port: 8181
  #   scheme: HTTP
  # initialDelaySeconds: 30
  # periodSeconds: 10
  # timeoutSeconds: 5
  # failureThreshold: 5
  # successThreshold: 1

externalDNSLivenessProbe: {}
externalDNSReadinessProbe: {}